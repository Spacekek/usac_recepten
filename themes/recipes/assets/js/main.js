console.log('This site was generated by Hugo.');

// Search and filter functionality
document.addEventListener('DOMContentLoaded', function() {
    const searchInput = document.getElementById('recipeSearch');
    const recipeList = document.getElementById('recipeList');
    const tagFilters = document.querySelectorAll('.tag-filter');
    const sortSelect = document.getElementById('sortBy');
    const resetBtn = document.querySelector('.reset-btn');
    const resultsCounter = document.querySelector('.results-counter');
    
    // Range filter inputs
    const prepMin = document.getElementById('prepMin');
    const prepMax = document.getElementById('prepMax');
    const cookMin = document.getElementById('cookMin');
    const cookMax = document.getElementById('cookMax');
    const totalMin = document.getElementById('totalMin');
    const totalMax = document.getElementById('totalMax');
    const priceMin = document.getElementById('priceMin');
    const priceMax = document.getElementById('priceMax');
    
    // Value display elements
    const prepMinVal = document.getElementById('prepMinVal');
    const prepMaxVal = document.getElementById('prepMaxVal');
    const cookMinVal = document.getElementById('cookMinVal');
    const cookMaxVal = document.getElementById('cookMaxVal');
    const totalMinVal = document.getElementById('totalMinVal');
    const totalMaxVal = document.getElementById('totalMaxVal');
    const priceMinVal = document.getElementById('priceMinVal');
    const priceMaxVal = document.getElementById('priceMaxVal');
    
    if (!searchInput || !recipeList) {
        return; // Elements not present on this page
    }
    
    let recipeItems = Array.from(recipeList.querySelectorAll('.recipe-item'));
    let activeTags = []; // Changed from single activeTag to array
    
    // Update slider value displays
    function updateSliderDisplay(slider, display) {
        if (slider && display) {
            display.textContent = slider.value;
            slider.addEventListener('input', function() {
                display.textContent = this.value;
                filterRecipes();
            });
        }
    }
    
    // Initialize all sliders
    updateSliderDisplay(prepMin, prepMinVal);
    updateSliderDisplay(prepMax, prepMaxVal);
    updateSliderDisplay(cookMin, cookMinVal);
    updateSliderDisplay(cookMax, cookMaxVal);
    updateSliderDisplay(totalMin, totalMinVal);
    updateSliderDisplay(totalMax, totalMaxVal);
    updateSliderDisplay(priceMin, priceMinVal);
    updateSliderDisplay(priceMax, priceMaxVal);
    
    // Search functionality
    searchInput.addEventListener('input', function() {
        filterRecipes();
    });
    
    // Tag filter functionality - support multiple tags
    tagFilters.forEach(function(filter) {
        filter.addEventListener('click', function() {
            const tagValue = this.getAttribute('data-tag');
            
            // Toggle active state
            if (this.classList.contains('active')) {
                // Remove from active tags
                this.classList.remove('active');
                const index = activeTags.indexOf(tagValue);
                if (index > -1) {
                    activeTags.splice(index, 1);
                }
            } else {
                // Add to active tags
                this.classList.add('active');
                activeTags.push(tagValue);
            }
            
            // Update active filters display
            updateActiveFiltersDisplay();
            
            // Filter recipes
            filterRecipes();
        });
    });
    
    // Update active filters display
    function updateActiveFiltersDisplay() {
        const activeFiltersDiv = document.getElementById('activeFilters');
        const activeFiltersList = document.getElementById('activeFiltersList');
        
        if (activeTags.length === 0) {
            activeFiltersDiv.style.display = 'none';
        } else {
            activeFiltersDiv.style.display = 'block';
            activeFiltersList.innerHTML = activeTags.map(tag => {
                const displayName = tag.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                return `<span class="active-filter-tag">${displayName} <span class="remove" data-tag="${tag}">×</span></span>`;
            }).join('');
            
            // Add click handlers to remove buttons
            activeFiltersList.querySelectorAll('.remove').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const tagToRemove = this.getAttribute('data-tag');
                    const tagFilter = document.querySelector(`.tag-filter[data-tag="${tagToRemove}"]`);
                    if (tagFilter) {
                        tagFilter.click();
                    }
                });
            });
        }
    }
    
    // Sort functionality
    if (sortSelect) {
        sortSelect.addEventListener('change', function() {
            sortRecipes(this.value);
            filterRecipes(); // Reapply filters after sorting
        });
    }
    
    // Reset filters functionality
    if (resetBtn) {
        resetBtn.addEventListener('click', function() {
            // Reset search
            searchInput.value = '';
            
            // Reset tags
            activeTags = [];
            tagFilters.forEach(f => f.classList.remove('active'));
            updateActiveFiltersDisplay();
            
            // Reset all sliders to their min/max
            if (prepMin) { prepMin.value = prepMin.min; prepMinVal.textContent = prepMin.min; }
            if (prepMax) { prepMax.value = prepMax.max; prepMaxVal.textContent = prepMax.max; }
            if (cookMin) { cookMin.value = cookMin.min; cookMinVal.textContent = cookMin.min; }
            if (cookMax) { cookMax.value = cookMax.max; cookMaxVal.textContent = cookMax.max; }
            if (totalMin) { totalMin.value = totalMin.min; totalMinVal.textContent = totalMin.min; }
            if (totalMax) { totalMax.value = totalMax.max; totalMaxVal.textContent = totalMax.max; }
            if (priceMin) { priceMin.value = priceMin.min; priceMinVal.textContent = priceMin.min; }
            if (priceMax) { priceMax.value = priceMax.max; priceMaxVal.textContent = priceMax.max; }
            
            // Reset sort to title
            if (sortSelect) sortSelect.value = 'title';
            
            // Refilter
            filterRecipes();
        });
    }
    
    function updateResultsCounter(visible, total) {
        if (resultsCounter) {
            resultsCounter.textContent = `Showing ${visible} of ${total} recipes`;
        }
    }
    
    function filterRecipes() {
        const searchTerm = searchInput.value.toLowerCase();
        
        // Get range filter values
        const filters = {
            prepMin: parseFloat(prepMin?.value) || 0,
            prepMax: parseFloat(prepMax?.value) || Infinity,
            cookMin: parseFloat(cookMin?.value) || 0,
            cookMax: parseFloat(cookMax?.value) || Infinity,
            totalMin: parseFloat(totalMin?.value) || 0,
            totalMax: parseFloat(totalMax?.value) || Infinity,
            priceMin: parseFloat(priceMin?.value) || 0,
            priceMax: parseFloat(priceMax?.value) || Infinity
        };
        
        let visibleCount = 0;
        
        recipeItems.forEach(function(item) {
            const title = item.getAttribute('data-title');
            const tags = item.getAttribute('data-tags').split(',');
            const prep = parseFloat(item.getAttribute('data-prep')) || 0;
            const cook = parseFloat(item.getAttribute('data-cook')) || 0;
            const total = parseFloat(item.getAttribute('data-total')) || 0;
            const price = parseFloat(item.getAttribute('data-price')) || 0;
            
            // Check if item matches search term
            const matchesSearch = !searchTerm || 
                title.includes(searchTerm) || 
                tags.some(tag => tag.includes(searchTerm));
            
            // Check if item matches ALL active tags (AND logic)
            const matchesTags = activeTags.length === 0 || 
                activeTags.every(activeTag => tags.includes(activeTag));
            
            // Check if item matches range filters (only if value exists)
            const matchesPrep = (prep === 0) || (prep >= filters.prepMin && prep <= filters.prepMax);
            const matchesCook = (cook === 0) || (cook >= filters.cookMin && cook <= filters.cookMax);
            const matchesTotal = (total === 0) || (total >= filters.totalMin && total <= filters.totalMax);
            const matchesPrice = (price === 0) || (price >= filters.priceMin && price <= filters.priceMax);
            
            // Show item only if it matches all filters
            if (matchesSearch && matchesTags && matchesPrep && matchesCook && matchesTotal && matchesPrice) {
                item.style.display = '';
                visibleCount++;
            } else {
                item.style.display = 'none';
            }
        });
        
        updateResultsCounter(visibleCount, recipeItems.length);
    }
    
    function sortRecipes(sortBy) {
        recipeItems.sort(function(a, b) {
            switch(sortBy) {
                case 'title':
                    return a.getAttribute('data-title').localeCompare(b.getAttribute('data-title'));
                
                case 'prep_time':
                    return parseFloat(a.getAttribute('data-prep') || 0) - parseFloat(b.getAttribute('data-prep') || 0);
                
                case 'cook_time':
                    return parseFloat(a.getAttribute('data-cook') || 0) - parseFloat(b.getAttribute('data-cook') || 0);
                
                case 'total_time':
                    return parseFloat(a.getAttribute('data-total') || 0) - parseFloat(b.getAttribute('data-total') || 0);
                
                case 'price':
                    return parseFloat(a.getAttribute('data-price') || 0) - parseFloat(b.getAttribute('data-price') || 0);
                
                default:
                    return 0;
            }
        });
        
        // Reorder DOM elements
        recipeItems.forEach(function(item) {
            recipeList.appendChild(item);
        });
        
        // Update the recipeItems array reference after sorting
        recipeItems = Array.from(recipeList.querySelectorAll('.recipe-item'));
    }
    
    // Initialize results counter
    updateResultsCounter(recipeItems.length, recipeItems.length);
});

// Recipe scaling functionality - defined in global scope
window.updateServings = function() {
    const servingsInput = document.getElementById('servingsInput');
    if (!servingsInput) return;
    
    const newServings = Math.max(1, parseInt(servingsInput.value) || 1);
    servingsInput.value = newServings; // Ensure valid value is displayed
    
    // Scale all ingredient quantities
    const ingredientsList = document.querySelector('article ul');
    if (!ingredientsList) return;
    
    const items = ingredientsList.querySelectorAll('li');
    const scaleFactor = newServings / window.originalServings;
    
    items.forEach(item => {
        // Store original text if not already stored
        if (!item.dataset.original) {
            item.dataset.original = item.textContent;
        }
        
        const originalText = item.dataset.original;
        
        // Find and scale numbers (supports fractions like 1/2, decimals, and whole numbers)
        const scaledText = originalText.replace(/(\d+(?:[\.,]\d+)?(?:\/\d+)?)/g, (match) => {
            let number;
            
            // Handle fractions
            if (match.includes('/')) {
                const [num, denom] = match.split('/').map(Number);
                number = num / denom;
            } else {
                number = parseFloat(match.replace(',', '.'));
            }
            
            const scaled = number * scaleFactor;
            
            // Format the result nicely
            if (scaled % 1 === 0) {
                return scaled.toString();
            } else if (Math.abs(scaled - 0.5) < 0.01) {
                return '½';
            } else if (Math.abs(scaled - 0.25) < 0.01) {
                return '¼';
            } else if (Math.abs(scaled - 0.75) < 0.01) {
                return '¾';
            } else if (Math.abs(scaled - 0.33) < 0.02) {
                return '⅓';
            } else if (Math.abs(scaled - 0.67) < 0.02) {
                return '⅔';
            } else {
                return scaled.toFixed(1).replace(/\.0$/, '');
            }
        });
        
        item.textContent = scaledText;
    });
};
